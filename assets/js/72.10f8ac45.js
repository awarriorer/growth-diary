(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{379:function(e,t,s){"use strict";s.r(t);var a=s(14),o=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"关于websocket"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关于websocket"}},[e._v("#")]),e._v(" 关于webSocket")]),e._v(" "),t("p",[e._v("在webSocket还未出世之前，网站要想实现即时通讯，都是采用HTTP轮询的方式来获取最新的服务器信息。比如，每隔一秒就请求一下服务器当前状态，即使服务端的数据没有任何变化，这个请求还是会发出，这造成了极度的资源浪费。只因为服务端无法主动给浏览器推送消息。")]),e._v(" "),t("p",[e._v("webSocket的出现，让上述的问题得以解决。")]),e._v(" "),t("p",[e._v("webSocket使用"),t("code",[e._v("ws")]),e._v("或者"),t("code",[e._v("wss")]),e._v("做统一的资源标识符。类似于HTTPS，其中"),t("code",[e._v("wss")]),e._v("表示是在"),t("code",[e._v("TLS")]),e._v("之上的webSocket。如")]),e._v(" "),t("div",{staticClass:"language-json line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-json"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// webSocket界的http")]),e._v("\nws"),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//example.com/wsapi")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// webSocket界的https")]),e._v("\nwss"),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//secure.example.com")]),e._v("\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br")])]),t("p",[e._v("websocket使用和 HTTP 相同的 TCP 端口，可以绕过大多数防火墙的限制。默认情况下，Websocket协议使用80端口；运行在TLS之上时，默认使用443端口。")]),e._v(" "),t("h2",{attrs:{id:"websocket的优点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#websocket的优点"}},[e._v("#")]),e._v(" webSocket的优点")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("较少的控制开销。在连接建立后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10字节（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的掩码。相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。")])]),e._v(" "),t("li",[t("p",[e._v("更强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的长轮询比较，其也能在短时间内更多次地传递数据。")])]),e._v(" "),t("li",[t("p",[e._v("保持连接状态。与HTTP不同的是，Websocket需要先建立连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。")])]),e._v(" "),t("li",[t("p",[e._v("更好的二进制支持。Websocket定义了二进制帧，相对HTTP，可以更轻松地处理二进制内容。")])]),e._v(" "),t("li",[t("p",[e._v("可以支持扩展。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持压缩等。")])]),e._v(" "),t("li",[t("p",[e._v("更好的压缩效果。相对于HTTP压缩，Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率。")])])]),e._v(" "),t("h2",{attrs:{id:"websocket-demo"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#websocket-demo"}},[e._v("#")]),e._v(" webSocket Demo")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/awarriorer/mycode/tree/master/http/webSocket-demo",target:"_blank",rel:"noopener noreferrer"}},[e._v("利用socket.io做的简单的demo"),t("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=o.exports}}]);