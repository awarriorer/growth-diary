(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{342:function(t,a,v){"use strict";v.r(a);var _=v(14),s=Object(_.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"写在前面"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#写在前面"}},[t._v("#")]),t._v(" 写在前面")]),t._v(" "),a("h2",{attrs:{id:"什么是设计模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是设计模式"}},[t._v("#")]),t._v(" 什么是设计模式？")]),t._v(" "),a("ul",[a("li",[t._v("是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结")]),t._v(" "),a("li",[t._v("软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案")])]),t._v(" "),a("h2",{attrs:{id:"为什么需要设计模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要设计模式"}},[t._v("#")]),t._v(" 为什么需要设计模式?")]),t._v(" "),a("ul",[a("li",[t._v("为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化")]),t._v(" "),a("li",[t._v("使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力")])]),t._v(" "),a("h2",{attrs:{id:"设计模式六大原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计模式六大原则"}},[t._v("#")]),t._v(" 设计模式六大原则")]),t._v(" "),a("ul",[a("li",[t._v("总原则,开闭原则: 扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果")]),t._v(" "),a("li",[t._v("单一职责原则: 每个类应该实现单一的职责，如若不然，就应该把类拆分")]),t._v(" "),a("li",[t._v("里氏替换原则: 子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它")]),t._v(" "),a("li",[t._v("依赖倒转原则: 面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。")]),t._v(" "),a("li",[t._v("接口隔离原则: 每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好")]),t._v(" "),a("li",[t._v("迪米特法则（最少知道原则): 一个类对自己依赖的类知道的越少越好,无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部。")]),t._v(" "),a("li",[t._v("量首先使用合成/聚合的方式，而不是使用继承")])])])}),[],!1,null,null,null);a.default=s.exports}}]);